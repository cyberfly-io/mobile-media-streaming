// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'live_flutter_api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `convert_direct_event`, `get_broadcast_holder`, `get_live_event_queue`, `get_subscription_holder`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`

/// Create a new live broadcast
Future<String> createLiveBroadcast({required String name}) =>
    RustLib.instance.api.crateApiLiveFlutterApiCreateLiveBroadcast(name: name);

/// Get the live broadcast ticket (simpler format)
Future<String> getLiveTicket() =>
    RustLib.instance.api.crateApiLiveFlutterApiGetLiveTicket();

/// Get the direct connection ticket (full address)
Future<String> getDirectTicket() =>
    RustLib.instance.api.crateApiLiveFlutterApiGetDirectTicket();

/// Add a video track to the catalog
Future<void> addVideoTrack({
  required FlutterVideoQuality quality,
  required String codec,
}) => RustLib.instance.api.crateApiLiveFlutterApiAddVideoTrack(
  quality: quality,
  codec: codec,
);

/// Broadcast catalog to all viewers
Future<void> broadcastCatalog() =>
    RustLib.instance.api.crateApiLiveFlutterApiBroadcastCatalog();

/// Broadcast a video chunk
Future<void> liveBroadcastChunk({
  required int index,
  required List<int> data,
}) => RustLib.instance.api.crateApiLiveFlutterApiLiveBroadcastChunk(
  index: index,
  data: data,
);

/// Broadcast metadata for a video file
Future<void> liveBroadcastMetadata({
  required String fileName,
  required BigInt fileSize,
  required String mimeType,
  required int totalChunks,
  double? duration,
}) => RustLib.instance.api.crateApiLiveFlutterApiLiveBroadcastMetadata(
  fileName: fileName,
  fileSize: fileSize,
  mimeType: mimeType,
  totalChunks: totalChunks,
  duration: duration,
);

/// Get broadcast peer count
Future<int> liveBroadcastPeerCount() =>
    RustLib.instance.api.crateApiLiveFlutterApiLiveBroadcastPeerCount();

/// Stop the live broadcast
Future<void> stopLiveBroadcast() =>
    RustLib.instance.api.crateApiLiveFlutterApiStopLiveBroadcast();

/// Join a live broadcast using ticket string
Future<String> joinLiveBroadcast({required String ticketStr}) => RustLib
    .instance
    .api
    .crateApiLiveFlutterApiJoinLiveBroadcast(ticketStr: ticketStr);

/// Request catalog from broadcaster
Future<void> requestLiveCatalog() =>
    RustLib.instance.api.crateApiLiveFlutterApiRequestLiveCatalog();

/// Request a specific chunk
Future<void> liveRequestChunk({required int index}) =>
    RustLib.instance.api.crateApiLiveFlutterApiLiveRequestChunk(index: index);

/// Set preferred video quality
Future<void> setVideoQuality({required FlutterVideoQuality quality}) => RustLib
    .instance
    .api
    .crateApiLiveFlutterApiSetVideoQuality(quality: quality);

/// Get recommended quality based on connection stats
Future<FlutterVideoQuality> getRecommendedQuality() =>
    RustLib.instance.api.crateApiLiveFlutterApiGetRecommendedQuality();

/// Get connection stats
Future<FlutterConnectionStats> getLiveConnectionStats() =>
    RustLib.instance.api.crateApiLiveFlutterApiGetLiveConnectionStats();

/// Leave the live broadcast
Future<void> leaveLiveBroadcast() =>
    RustLib.instance.api.crateApiLiveFlutterApiLeaveLiveBroadcast();

/// Poll for live streaming events
Future<List<FlutterLiveEvent>> pollLiveEvents() =>
    RustLib.instance.api.crateApiLiveFlutterApiPollLiveEvents();

/// Parse a LiveTicket string and return its components
Future<(String, String)> parseLiveTicket({required String ticketStr}) => RustLib
    .instance
    .api
    .crateApiLiveFlutterApiParseLiveTicket(ticketStr: ticketStr);

/// Create a LiveTicket string from components
Future<String> createLiveTicket({
  required String broadcastName,
  required String endpointIdHex,
}) => RustLib.instance.api.crateApiLiveFlutterApiCreateLiveTicket(
  broadcastName: broadcastName,
  endpointIdHex: endpointIdHex,
);

/// Check if there's an active broadcast
Future<bool> hasActiveBroadcast() =>
    RustLib.instance.api.crateApiLiveFlutterApiHasActiveBroadcast();

/// Check if there's an active subscription
Future<bool> hasActiveSubscription() =>
    RustLib.instance.api.crateApiLiveFlutterApiHasActiveSubscription();

/// Get video quality dimensions
Future<(int, int)> getQualityDimensions({
  required FlutterVideoQuality quality,
}) => RustLib.instance.api.crateApiLiveFlutterApiGetQualityDimensions(
  quality: quality,
);

/// Get video quality bitrate recommendation
Future<int> getQualityBitrate({required FlutterVideoQuality quality}) => RustLib
    .instance
    .api
    .crateApiLiveFlutterApiGetQualityBitrate(quality: quality);

/// Get all video qualities
Future<List<FlutterVideoQuality>> getAllVideoQualities() =>
    RustLib.instance.api.crateApiLiveFlutterApiGetAllVideoQualities();

/// Broadcast catalog for Flutter
class FlutterCatalog {
  final String name;
  final String? description;
  final List<FlutterVideoTrack> videoTracks;
  final bool isLive;
  final double? durationSecs;

  const FlutterCatalog({
    required this.name,
    this.description,
    required this.videoTracks,
    required this.isLive,
    this.durationSecs,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      videoTracks.hashCode ^
      isLive.hashCode ^
      durationSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterCatalog &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          videoTracks == other.videoTracks &&
          isLive == other.isLive &&
          durationSecs == other.durationSecs;
}

/// Connection stats for Flutter
class FlutterConnectionStats {
  final BigInt bytesSent;
  final BigInt bytesReceived;
  final BigInt chunksSent;
  final BigInt chunksReceived;
  final BigInt bandwidthBps;
  final BigInt rttMs;
  final int qualityScore;
  final FlutterVideoQuality recommendedQuality;

  const FlutterConnectionStats({
    required this.bytesSent,
    required this.bytesReceived,
    required this.chunksSent,
    required this.chunksReceived,
    required this.bandwidthBps,
    required this.rttMs,
    required this.qualityScore,
    required this.recommendedQuality,
  });

  @override
  int get hashCode =>
      bytesSent.hashCode ^
      bytesReceived.hashCode ^
      chunksSent.hashCode ^
      chunksReceived.hashCode ^
      bandwidthBps.hashCode ^
      rttMs.hashCode ^
      qualityScore.hashCode ^
      recommendedQuality.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterConnectionStats &&
          runtimeType == other.runtimeType &&
          bytesSent == other.bytesSent &&
          bytesReceived == other.bytesReceived &&
          chunksSent == other.chunksSent &&
          chunksReceived == other.chunksReceived &&
          bandwidthBps == other.bandwidthBps &&
          rttMs == other.rttMs &&
          qualityScore == other.qualityScore &&
          recommendedQuality == other.recommendedQuality;
}

@freezed
sealed class FlutterLiveEvent with _$FlutterLiveEvent {
  const FlutterLiveEvent._();

  /// Peer connected
  const factory FlutterLiveEvent.peerConnected({required String peerId}) =
      FlutterLiveEvent_PeerConnected;

  /// Peer disconnected
  const factory FlutterLiveEvent.peerDisconnected({required String peerId}) =
      FlutterLiveEvent_PeerDisconnected;

  /// Catalog received
  const factory FlutterLiveEvent.catalogReceived({
    required FlutterCatalog catalog,
  }) = FlutterLiveEvent_CatalogReceived;

  /// Metadata received (for video file streaming)
  const factory FlutterLiveEvent.metadataReceived({
    required String from,
    required String fileName,
    required BigInt fileSize,
    required String mimeType,
    required int totalChunks,
    double? duration,
  }) = FlutterLiveEvent_MetadataReceived;

  /// Chunk request received (for broadcaster)
  const factory FlutterLiveEvent.chunkRequested({
    required String from,
    required int index,
  }) = FlutterLiveEvent_ChunkRequested;

  /// Chunk received (for viewer)
  const factory FlutterLiveEvent.chunkReceived({
    required String from,
    required int index,
    required Uint8List data,
  }) = FlutterLiveEvent_ChunkReceived;

  /// Metadata request received
  const factory FlutterLiveEvent.metadataRequested({required String from}) =
      FlutterLiveEvent_MetadataRequested;

  /// Stats updated
  const factory FlutterLiveEvent.statsUpdated({
    required FlutterConnectionStats stats,
  }) = FlutterLiveEvent_StatsUpdated;

  /// Error occurred
  const factory FlutterLiveEvent.error({required String message}) =
      FlutterLiveEvent_Error;
}

/// Video quality enum for Flutter
enum FlutterVideoQuality { p180, p360, p720, p1080 }

/// Video track info for Flutter
class FlutterVideoTrack {
  final String name;
  final FlutterVideoQuality quality;
  final String codec;
  final int width;
  final int height;
  final int fps;
  final int bitrateKbps;

  const FlutterVideoTrack({
    required this.name,
    required this.quality,
    required this.codec,
    required this.width,
    required this.height,
    required this.fps,
    required this.bitrateKbps,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      quality.hashCode ^
      codec.hashCode ^
      width.hashCode ^
      height.hashCode ^
      fps.hashCode ^
      bitrateKbps.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterVideoTrack &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          quality == other.quality &&
          codec == other.codec &&
          width == other.width &&
          height == other.height &&
          fps == other.fps &&
          bitrateKbps == other.bitrateKbps;
}
