// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'flutter_api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_event_queue`, `get_node_holder`, `get_sender_holder`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`

/// Initialize the streaming node
Future<String> initStreamingNode() =>
    RustLib.instance.api.crateApiFlutterApiInitStreamingNode();

/// Get the endpoint ID
Future<String> getEndpointId() =>
    RustLib.instance.api.crateApiFlutterApiGetEndpointId();

/// Create a new stream (as broadcaster) and return the ticket
Future<String> createStream({required String name}) =>
    RustLib.instance.api.crateApiFlutterApiCreateStream(name: name);

/// Join an existing stream as a viewer
Future<String> joinStream({required String ticketStr, required String name}) =>
    RustLib.instance.api.crateApiFlutterApiJoinStream(
      ticketStr: ticketStr,
      name: name,
    );

/// Broadcast a media chunk (for broadcaster)
Future<void> broadcastChunk({
  required List<int> data,
  required BigInt sequence,
}) => RustLib.instance.api.crateApiFlutterApiBroadcastChunk(
  data: data,
  sequence: sequence,
);

/// Send a presence message
Future<void> sendPresence() =>
    RustLib.instance.api.crateApiFlutterApiSendPresence();

/// Send a signal message (for WebRTC signaling, etc.)
Future<void> sendSignal({required List<int> data}) =>
    RustLib.instance.api.crateApiFlutterApiSendSignal(data: data);

/// Poll for received events (returns all queued events)
Future<List<FlutterStreamEvent>> pollEvents() =>
    RustLib.instance.api.crateApiFlutterApiPollEvents();

/// Get quality constraints for a preset
QualityConstraints getQualityConstraints({required Quality quality}) => RustLib
    .instance
    .api
    .crateApiFlutterApiGetQualityConstraints(quality: quality);

/// Leave the current stream
Future<void> leaveStream() =>
    RustLib.instance.api.crateApiFlutterApiLeaveStream();

/// Shutdown the streaming node
Future<void> shutdownStreaming() =>
    RustLib.instance.api.crateApiFlutterApiShutdownStreaming();

/// Check if streaming node is initialized
bool isStreamingInitialized() =>
    RustLib.instance.api.crateApiFlutterApiIsStreamingInitialized();

/// Check if connected to a stream
bool isConnectedToStream() =>
    RustLib.instance.api.crateApiFlutterApiIsConnectedToStream();

@freezed
sealed class FlutterStreamEvent with _$FlutterStreamEvent {
  const FlutterStreamEvent._();

  const factory FlutterStreamEvent.neighborUp({required String endpointId}) =
      FlutterStreamEvent_NeighborUp;
  const factory FlutterStreamEvent.neighborDown({required String endpointId}) =
      FlutterStreamEvent_NeighborDown;
  const factory FlutterStreamEvent.presence({
    required String from,
    required String name,
    required BigInt timestamp,
  }) = FlutterStreamEvent_Presence;
  const factory FlutterStreamEvent.mediaChunk({
    required String from,
    required Uint8List data,
    required BigInt sequence,
    required BigInt timestamp,
  }) = FlutterStreamEvent_MediaChunk;
  const factory FlutterStreamEvent.signal({
    required String from,
    required Uint8List data,
    required BigInt timestamp,
  }) = FlutterStreamEvent_Signal;
  const factory FlutterStreamEvent.lagged() = FlutterStreamEvent_Lagged;
  const factory FlutterStreamEvent.error({required String message}) =
      FlutterStreamEvent_Error;
}

/// Quality preset for streaming
enum Quality { low, medium, high, ultra }

/// Quality constraints returned to Flutter
class QualityConstraints {
  final int width;
  final int height;
  final int framerate;
  final int audioBitrate;

  const QualityConstraints({
    required this.width,
    required this.height,
    required this.framerate,
    required this.audioBitrate,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      framerate.hashCode ^
      audioBitrate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QualityConstraints &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          framerate == other.framerate &&
          audioBitrate == other.audioBitrate;
}
