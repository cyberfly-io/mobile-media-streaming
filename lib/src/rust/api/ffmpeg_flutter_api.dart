// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_audio_decoder`, `get_audio_encoder`, `get_quality_ladder`, `get_video_decoder`, `get_video_encoder`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Create a video encoder
Future<void> ffmpegCreateVideoEncoder({
  required FlutterVideoQualityFfmpeg quality,
  required FlutterVideoCodec codec,
  required FlutterHardwareAccel hardware,
  required FlutterEncoderPreset preset,
  int? bitrateKbps,
  required bool lowLatency,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateVideoEncoder(
  quality: quality,
  codec: codec,
  hardware: hardware,
  preset: preset,
  bitrateKbps: bitrateKbps,
  lowLatency: lowLatency,
);

/// Encode a raw video frame (RGBA format)
Future<FlutterEncodedVideoFrame> ffmpegEncodeVideoFrame({
  required List<int> rawFrame,
  required PlatformInt64 ptsUs,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegEncodeVideoFrame(
  rawFrame: rawFrame,
  ptsUs: ptsUs,
);

/// Flush remaining video frames
Future<List<FlutterEncodedVideoFrame>> ffmpegFlushVideoEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegFlushVideoEncoder();

/// Reset video encoder
Future<void> ffmpegResetVideoEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegResetVideoEncoder();

/// Destroy video encoder
Future<void> ffmpegDestroyVideoEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDestroyVideoEncoder();

/// Create a video decoder
Future<void> ffmpegCreateVideoDecoder({
  required FlutterVideoCodec codec,
  required FlutterHardwareAccel hardware,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateVideoDecoder(
  codec: codec,
  hardware: hardware,
);

/// Decode a video frame
Future<FlutterDecodedVideoFrame> ffmpegDecodeVideoFrame({
  required List<int> data,
  required PlatformInt64 ptsUs,
  required bool isKeyframe,
  required FlutterVideoQualityFfmpeg quality,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDecodeVideoFrame(
  data: data,
  ptsUs: ptsUs,
  isKeyframe: isKeyframe,
  quality: quality,
);

/// Destroy video decoder
Future<void> ffmpegDestroyVideoDecoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDestroyVideoDecoder();

/// Create an audio encoder
Future<void> ffmpegCreateAudioEncoder({
  required FlutterAudioCodec codec,
  required int sampleRate,
  required int channels,
  required int bitrateKbps,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateAudioEncoder(
  codec: codec,
  sampleRate: sampleRate,
  channels: channels,
  bitrateKbps: bitrateKbps,
);

/// Create a voice-optimized audio encoder (Opus, low latency)
Future<void> ffmpegCreateVoiceEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateVoiceEncoder();

/// Create a music-optimized audio encoder (AAC, high quality)
Future<void> ffmpegCreateMusicEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateMusicEncoder();

/// Encode PCM audio (16-bit signed, interleaved)
Future<FlutterEncodedAudioFrame> ffmpegEncodeAudioFrame({
  required List<int> pcmSamples,
  required PlatformInt64 ptsUs,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegEncodeAudioFrame(
  pcmSamples: pcmSamples,
  ptsUs: ptsUs,
);

/// Destroy audio encoder
Future<void> ffmpegDestroyAudioEncoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDestroyAudioEncoder();

/// Create an audio decoder
Future<void> ffmpegCreateAudioDecoder({required FlutterAudioCodec codec}) =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateAudioDecoder(
      codec: codec,
    );

/// Decode audio frame to PCM
Future<FlutterDecodedAudioFrame> ffmpegDecodeAudioFrame({
  required List<int> data,
  required PlatformInt64 ptsUs,
  required FlutterAudioCodec codec,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDecodeAudioFrame(
  data: data,
  ptsUs: ptsUs,
  codec: codec,
);

/// Destroy audio decoder
Future<void> ffmpegDestroyAudioDecoder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDestroyAudioDecoder();

/// Create a quality ladder for adaptive bitrate streaming
Future<List<String>> ffmpegCreateQualityLadder({
  required FlutterVideoQualityFfmpeg sourceQuality,
  required FlutterVideoCodec codec,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegCreateQualityLadder(
  sourceQuality: sourceQuality,
  codec: codec,
);

/// Encode a frame to all quality levels
Future<List<FlutterEncodedVideoFrame>> ffmpegEncodeAllQualities({
  required List<int> rawFrame,
  required PlatformInt64 ptsUs,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegEncodeAllQualities(
  rawFrame: rawFrame,
  ptsUs: ptsUs,
);

/// Destroy quality ladder
Future<void> ffmpegDestroyQualityLadder() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDestroyQualityLadder();

/// Check if FFmpeg is available
Future<bool> ffmpegIsAvailable() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegIsAvailable();

/// Get FFmpeg version (if available)
Future<String?> ffmpegGetVersion() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetVersion();

/// Detect available hardware acceleration
Future<FlutterHardwareAccel> ffmpegDetectHardware() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegDetectHardware();

/// List all available hardware accelerations
Future<List<String>> ffmpegListHardwareAccels() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegListHardwareAccels();

/// List all available video codecs
Future<List<String>> ffmpegListVideoCodecs() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegListVideoCodecs();

/// List all available audio codecs
Future<List<String>> ffmpegListAudioCodecs() =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegListAudioCodecs();

/// Get codec MIME type
Future<String> ffmpegGetVideoMimeType({required FlutterVideoCodec codec}) =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetVideoMimeType(
      codec: codec,
    );

/// Get audio codec MIME type
Future<String> ffmpegGetAudioMimeType({required FlutterAudioCodec codec}) =>
    RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetAudioMimeType(
      codec: codec,
    );

/// Get recommended bitrate for quality
Future<int> ffmpegGetRecommendedBitrate({
  required FlutterVideoQualityFfmpeg quality,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetRecommendedBitrate(
  quality: quality,
);

/// Get quality dimensions
Future<(int, int)> ffmpegGetQualityDimensions({
  required FlutterVideoQualityFfmpeg quality,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetQualityDimensions(
  quality: quality,
);

/// Get recommended audio bitrate
Future<int> ffmpegGetAudioBitrate({
  required FlutterAudioCodec codec,
  required bool highQuality,
}) => RustLib.instance.api.crateApiFfmpegFlutterApiFfmpegGetAudioBitrate(
  codec: codec,
  highQuality: highQuality,
);

/// Audio codec for Flutter
enum FlutterAudioCodec { aac, opus, mp3 }

/// Decoded audio frame for Flutter
class FlutterDecodedAudioFrame {
  final Int16List samples;
  final PlatformInt64 ptsUs;
  final int sampleRate;
  final int channels;

  const FlutterDecodedAudioFrame({
    required this.samples,
    required this.ptsUs,
    required this.sampleRate,
    required this.channels,
  });

  @override
  int get hashCode =>
      samples.hashCode ^
      ptsUs.hashCode ^
      sampleRate.hashCode ^
      channels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterDecodedAudioFrame &&
          runtimeType == other.runtimeType &&
          samples == other.samples &&
          ptsUs == other.ptsUs &&
          sampleRate == other.sampleRate &&
          channels == other.channels;
}

/// Decoded video frame for Flutter
class FlutterDecodedVideoFrame {
  final Uint8List data;
  final int width;
  final int height;
  final PlatformInt64 ptsUs;
  final bool isKeyframe;

  const FlutterDecodedVideoFrame({
    required this.data,
    required this.width,
    required this.height,
    required this.ptsUs,
    required this.isKeyframe,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      width.hashCode ^
      height.hashCode ^
      ptsUs.hashCode ^
      isKeyframe.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterDecodedVideoFrame &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          width == other.width &&
          height == other.height &&
          ptsUs == other.ptsUs &&
          isKeyframe == other.isKeyframe;
}

/// Encoded audio frame for Flutter
class FlutterEncodedAudioFrame {
  final Uint8List data;
  final PlatformInt64 ptsUs;
  final PlatformInt64 durationUs;
  final int samples;
  final FlutterAudioCodec codec;

  const FlutterEncodedAudioFrame({
    required this.data,
    required this.ptsUs,
    required this.durationUs,
    required this.samples,
    required this.codec,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      ptsUs.hashCode ^
      durationUs.hashCode ^
      samples.hashCode ^
      codec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterEncodedAudioFrame &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          ptsUs == other.ptsUs &&
          durationUs == other.durationUs &&
          samples == other.samples &&
          codec == other.codec;
}

/// Encoded video frame for Flutter
class FlutterEncodedVideoFrame {
  final Uint8List data;
  final PlatformInt64 ptsUs;
  final PlatformInt64 dtsUs;
  final bool isKeyframe;
  final PlatformInt64 durationUs;
  final BigInt frameIndex;
  final FlutterVideoCodec codec;

  /// MoQ priority (0-255, lower = higher priority)
  final int moqPriority;

  /// MoQ TTL in milliseconds
  final BigInt moqTtlMs;

  const FlutterEncodedVideoFrame({
    required this.data,
    required this.ptsUs,
    required this.dtsUs,
    required this.isKeyframe,
    required this.durationUs,
    required this.frameIndex,
    required this.codec,
    required this.moqPriority,
    required this.moqTtlMs,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      ptsUs.hashCode ^
      dtsUs.hashCode ^
      isKeyframe.hashCode ^
      durationUs.hashCode ^
      frameIndex.hashCode ^
      codec.hashCode ^
      moqPriority.hashCode ^
      moqTtlMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterEncodedVideoFrame &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          ptsUs == other.ptsUs &&
          dtsUs == other.dtsUs &&
          isKeyframe == other.isKeyframe &&
          durationUs == other.durationUs &&
          frameIndex == other.frameIndex &&
          codec == other.codec &&
          moqPriority == other.moqPriority &&
          moqTtlMs == other.moqTtlMs;
}

/// Encoder preset for Flutter
enum FlutterEncoderPreset { ultrafast, superfast, fast, medium, slow, veryslow }

/// Hardware acceleration for Flutter
enum FlutterHardwareAccel { none, videoToolbox, mediaCodec, nvenc, qsv, amf }

/// Video codec for Flutter
enum FlutterVideoCodec { h264, h265, vp8, vp9, av1 }

/// Video quality for Flutter (reusing live_flutter_api enum)
enum FlutterVideoQualityFfmpeg { p180, p360, p720, p1080 }
