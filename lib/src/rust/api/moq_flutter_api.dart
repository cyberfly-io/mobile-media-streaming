// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'moq_flutter_api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_namespace_manager`, `get_scheduler`, `get_track_store`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Create a new track (publisher)
Future<FlutterTrackStatus> moqCreateTrack({required String trackPath}) =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqCreateTrack(
      trackPath: trackPath,
    );

/// Start a new group in a track (returns group_id)
Future<BigInt> moqStartGroup({required String trackPath}) => RustLib
    .instance
    .api
    .crateApiMoqFlutterApiMoqStartGroup(trackPath: trackPath);

/// Add an object to a group
/// - priority: 0-255, lower = higher priority (default 128)
/// - ttl_ms: optional time-to-live in milliseconds
Future<FlutterMoqObject> moqAddObject({
  required String trackPath,
  required BigInt groupId,
  required BigInt subgroupId,
  required List<int> payload,
  int? priority,
  BigInt? ttlMs,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqAddObject(
  trackPath: trackPath,
  groupId: groupId,
  subgroupId: subgroupId,
  payload: payload,
  priority: priority,
  ttlMs: ttlMs,
);

/// Get track status
Future<FlutterTrackStatus> moqGetTrackStatus({required String trackPath}) =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetTrackStatus(
      trackPath: trackPath,
    );

/// Subscribe to a track with filter
Future<List<FlutterMoqObject>> moqSubscribe({
  required String trackPath,
  required FlutterFilterType filter,
  required FlutterGroupOrder groupOrder,
  required int subscriberPriority,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqSubscribe(
  trackPath: trackPath,
  filter: filter,
  groupOrder: groupOrder,
  subscriberPriority: subscriberPriority,
);

/// Subscribe starting from latest group (convenience function)
Future<List<FlutterMoqObject>> moqSubscribeLatestGroup({
  required String trackPath,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqSubscribeLatestGroup(
  trackPath: trackPath,
);

/// Subscribe to live edge (NextGroup - real-time only)
Future<List<FlutterMoqObject>> moqSubscribeLive({required String trackPath}) =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqSubscribeLive(
      trackPath: trackPath,
    );

/// Subscribe with range (for catch-up/VOD)
Future<List<FlutterMoqObject>> moqSubscribeRange({
  required String trackPath,
  required BigInt startGroup,
  required BigInt startObject,
  required BigInt endGroup,
  BigInt? endObject,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqSubscribeRange(
  trackPath: trackPath,
  startGroup: startGroup,
  startObject: startObject,
  endGroup: endGroup,
  endObject: endObject,
);

/// Fetch historical objects from a track
Future<List<FlutterMoqObject>> moqFetch({
  required String trackPath,
  required BigInt startGroup,
  required BigInt startObject,
  required BigInt endGroup,
  BigInt? endObject,
  int? priority,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqFetch(
  trackPath: trackPath,
  startGroup: startGroup,
  startObject: startObject,
  endGroup: endGroup,
  endObject: endObject,
  priority: priority,
);

/// Enqueue an object for priority-based delivery
Future<void> moqEnqueueObject({
  required BigInt groupId,
  required BigInt subgroupId,
  required BigInt objectId,
  required List<int> payload,
  required int publisherPriority,
  required int subscriberPriority,
  BigInt? ttlMs,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqEnqueueObject(
  groupId: groupId,
  subgroupId: subgroupId,
  objectId: objectId,
  payload: payload,
  publisherPriority: publisherPriority,
  subscriberPriority: subscriberPriority,
  ttlMs: ttlMs,
);

/// Dequeue the highest priority object
Future<FlutterMoqObject?> moqDequeueObject() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqDequeueObject();

/// Get scheduler queue length
Future<int> moqGetQueueLength() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetQueueLength();

/// Drop low priority objects during congestion
/// Returns number of objects dropped
Future<int> moqDropLowPriority({required int threshold}) => RustLib.instance.api
    .crateApiMoqFlutterApiMoqDropLowPriority(threshold: threshold);

/// Announce a namespace (make tracks available for discovery)
Future<void> moqAnnounceNamespace({
  required String namespacePath,
  required List<String> tracks,
  required bool acceptsPublishing,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqAnnounceNamespace(
  namespacePath: namespacePath,
  tracks: tracks,
  acceptsPublishing: acceptsPublishing,
);

/// Subscribe to a namespace prefix (discover namespaces)
Future<List<FlutterNamespaceAnnouncement>> moqSubscribeNamespace({
  required String namespacePrefix,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqSubscribeNamespace(
  namespacePrefix: namespacePrefix,
);

/// List all published namespaces
Future<List<FlutterNamespaceAnnouncement>> moqListNamespaces() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqListNamespaces();

/// Get announcement for specific namespace
Future<FlutterNamespaceAnnouncement?> moqGetNamespace({
  required String namespacePath,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqGetNamespace(
  namespacePath: namespacePath,
);

/// Get all available filter types (for UI)
Future<List<String>> moqGetFilterTypes() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetFilterTypes();

/// Get all group order options
Future<List<String>> moqGetGroupOrders() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetGroupOrders();

/// Get priority range info
Future<(int, int, int)> moqGetPriorityInfo() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetPriorityInfo();

/// Parse a track path into namespace and track name
Future<(String, String)> moqParseTrackPath({required String trackPath}) =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqParseTrackPath(
      trackPath: trackPath,
    );

/// Create a track path from namespace and track name
Future<String> moqCreateTrackPath({
  required String namespace,
  required String trackName,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqCreateTrackPath(
  namespace: namespace,
  trackName: trackName,
);

/// Check if one namespace is a prefix of another
Future<bool> moqNamespaceIsPrefix({
  required String prefix,
  required String fullPath,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqNamespaceIsPrefix(
  prefix: prefix,
  fullPath: fullPath,
);

/// Create an end-of-group marker object
Future<FlutterMoqObject> moqCreateEndOfGroup({
  required String trackPath,
  required BigInt groupId,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqCreateEndOfGroup(
  trackPath: trackPath,
  groupId: groupId,
);

/// Create an end-of-track marker object
Future<FlutterMoqObject> moqCreateEndOfTrack({
  required String trackPath,
  required BigInt groupId,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqCreateEndOfTrack(
  trackPath: trackPath,
  groupId: groupId,
);

/// Get estimated delivery time based on priority
Future<int> moqEstimateDeliveryTime({
  required int priority,
  required int queueLength,
}) => RustLib.instance.api.crateApiMoqFlutterApiMoqEstimateDeliveryTime(
  priority: priority,
  queueLength: queueLength,
);

Future<FlutterMoqStats> moqGetStats() =>
    RustLib.instance.api.crateApiMoqFlutterApiMoqGetStats();

@freezed
sealed class FlutterFilterType with _$FlutterFilterType {
  const FlutterFilterType._();

  /// Start from the latest complete group
  const factory FlutterFilterType.latestGroup() = FlutterFilterType_LatestGroup;

  /// Start from the latest object
  const factory FlutterFilterType.latestObject() =
      FlutterFilterType_LatestObject;

  /// Start from next group (live edge, real-time only)
  const factory FlutterFilterType.nextGroup() = FlutterFilterType_NextGroup;

  /// Start from absolute position
  const factory FlutterFilterType.absoluteStart({
    required BigInt startGroup,
    required BigInt startObject,
  }) = FlutterFilterType_AbsoluteStart;

  /// Request a range of objects (for VOD/catch-up)
  const factory FlutterFilterType.absoluteRange({
    required BigInt startGroup,
    required BigInt startObject,
    required BigInt endGroup,
    BigInt? endObject,
  }) = FlutterFilterType_AbsoluteRange;
}

/// Group delivery order for Flutter
enum FlutterGroupOrder {
  /// Oldest groups first (default for live)
  ascending,

  /// Newest groups first (for catch-up)
  descending,

  /// Use publisher's default
  publisherDefault,
}

/// MoQ Object for Flutter
class FlutterMoqObject {
  final BigInt groupId;
  final BigInt subgroupId;
  final BigInt objectId;
  final int publisherPriority;
  final BigInt? expiresAt;
  final FlutterObjectStatus status;
  final Uint8List payload;
  final BigInt createdAt;
  final bool isExpired;

  const FlutterMoqObject({
    required this.groupId,
    required this.subgroupId,
    required this.objectId,
    required this.publisherPriority,
    this.expiresAt,
    required this.status,
    required this.payload,
    required this.createdAt,
    required this.isExpired,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      subgroupId.hashCode ^
      objectId.hashCode ^
      publisherPriority.hashCode ^
      expiresAt.hashCode ^
      status.hashCode ^
      payload.hashCode ^
      createdAt.hashCode ^
      isExpired.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterMoqObject &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          subgroupId == other.subgroupId &&
          objectId == other.objectId &&
          publisherPriority == other.publisherPriority &&
          expiresAt == other.expiresAt &&
          status == other.status &&
          payload == other.payload &&
          createdAt == other.createdAt &&
          isExpired == other.isExpired;
}

/// Get MoQ system statistics
class FlutterMoqStats {
  final int schedulerQueueLength;
  final int namespaceCount;

  const FlutterMoqStats({
    required this.schedulerQueueLength,
    required this.namespaceCount,
  });

  @override
  int get hashCode => schedulerQueueLength.hashCode ^ namespaceCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterMoqStats &&
          runtimeType == other.runtimeType &&
          schedulerQueueLength == other.schedulerQueueLength &&
          namespaceCount == other.namespaceCount;
}

/// Namespace announcement for Flutter
class FlutterNamespaceAnnouncement {
  final String namespacePath;
  final List<String> tracks;
  final bool acceptsPublishing;

  const FlutterNamespaceAnnouncement({
    required this.namespacePath,
    required this.tracks,
    required this.acceptsPublishing,
  });

  @override
  int get hashCode =>
      namespacePath.hashCode ^ tracks.hashCode ^ acceptsPublishing.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterNamespaceAnnouncement &&
          runtimeType == other.runtimeType &&
          namespacePath == other.namespacePath &&
          tracks == other.tracks &&
          acceptsPublishing == other.acceptsPublishing;
}

/// Object delivery status for Flutter
enum FlutterObjectStatus {
  /// Normal object with payload
  normal,

  /// Object does not exist
  doesNotExist,

  /// End of group marker
  endOfGroup,

  /// End of track marker
  endOfTrack,

  /// End of subgroup marker
  endOfSubgroup,
}

/// Track status info for Flutter
class FlutterTrackStatus {
  final String trackPath;
  final FlutterTrackStatusCode status;
  final BigInt? latestGroupId;
  final BigInt? latestObjectId;
  final FlutterGroupOrder groupOrder;
  final int publisherPriority;

  const FlutterTrackStatus({
    required this.trackPath,
    required this.status,
    this.latestGroupId,
    this.latestObjectId,
    required this.groupOrder,
    required this.publisherPriority,
  });

  @override
  int get hashCode =>
      trackPath.hashCode ^
      status.hashCode ^
      latestGroupId.hashCode ^
      latestObjectId.hashCode ^
      groupOrder.hashCode ^
      publisherPriority.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterTrackStatus &&
          runtimeType == other.runtimeType &&
          trackPath == other.trackPath &&
          status == other.status &&
          latestGroupId == other.latestGroupId &&
          latestObjectId == other.latestObjectId &&
          groupOrder == other.groupOrder &&
          publisherPriority == other.publisherPriority;
}

/// Track status code for Flutter
enum FlutterTrackStatusCode { active, notFound, paused, ended, unknown }
