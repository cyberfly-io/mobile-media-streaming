// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `generate_color_bars`, `generate_gradient`, `generate_moving_box`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CaptureState`, `PublishState`, `SubscribeState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize the iroh-live node
Future<String> irohNodeInit() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohNodeInit();

/// Get the node's endpoint ID
Future<String> irohNodeGetEndpointId() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohNodeGetEndpointId();

/// Shutdown the node
Future<void> irohNodeShutdown() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohNodeShutdown();

/// Initialize the capture system
bool irohCaptureInit() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCaptureInit();

/// List available capture devices
List<FlutterCaptureDevice> irohCaptureListDevices() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCaptureListDevices();

/// Start capturing from a device
bool irohCaptureStart({required String deviceId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohCaptureStart(deviceId: deviceId);

/// Stop capturing
bool irohCaptureStop() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCaptureStop();

/// Get current capture device
String? irohCaptureCurrentDevice() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCaptureCurrentDevice();

/// Generate a test frame (for testing)
FlutterVideoFrame irohCaptureGetTestFrame({
  required int width,
  required int height,
  required String pattern,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCaptureGetTestFrame(
  width: width,
  height: height,
  pattern: pattern,
);

/// Create a new publisher and get the broadcast ticket
/// Returns the ticket string that can be shared with subscribers
Future<String> irohPublishCreateAsync({
  required String publisherId,
  required String broadcastName,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishCreateAsync(
  publisherId: publisherId,
  broadcastName: broadcastName,
);

/// Create a new publisher (sync version for compatibility)
bool irohPublishCreate({required String publisherId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohPublishCreate(publisherId: publisherId);

/// Start publishing (async version with real backend)
Future<void> irohPublishStartAsync({required String publisherId}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohPublishStartAsync(publisherId: publisherId);

/// Start publishing (sync version for compatibility)
bool irohPublishStart({required String publisherId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohPublishStart(publisherId: publisherId);

/// Stop publishing (async version)
Future<void> irohPublishStopAsync({required String publisherId}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohPublishStopAsync(publisherId: publisherId);

/// Stop publishing (sync version)
bool irohPublishStop({required String publisherId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohPublishStop(publisherId: publisherId);

/// Remove a publisher
bool irohPublishRemove({required String publisherId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohPublishRemove(publisherId: publisherId);

/// Push a video frame to publisher
bool irohPublishPushVideo({
  required String publisherId,
  required FlutterVideoFrame frame,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishPushVideo(
  publisherId: publisherId,
  frame: frame,
);

/// Push audio samples to publisher
bool irohPublishPushAudio({
  required String publisherId,
  required FlutterAudioSamples samples,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishPushAudio(
  publisherId: publisherId,
  samples: samples,
);

/// Push an already-encoded video packet to publisher
///
/// Use this when encoding is done on the Flutter side (e.g., using FFmpegKit).
/// This is the preferred method for mobile platforms where Rust FFmpeg
/// cross-compilation is difficult.
bool irohPublishPushEncodedVideo({
  required String publisherId,
  required FlutterEncodedVideoPacket packet,
}) =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishPushEncodedVideo(
      publisherId: publisherId,
      packet: packet,
    );

/// Push an already-encoded audio packet to publisher
bool irohPublishPushEncodedAudio({
  required String publisherId,
  required FlutterEncodedAudioPacket packet,
}) =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishPushEncodedAudio(
      publisherId: publisherId,
      packet: packet,
    );

/// Get publisher status
FlutterPublisherStatus? irohPublishGetStatus({required String publisherId}) =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohPublishGetStatus(
      publisherId: publisherId,
    );

/// Set video renditions for publisher
bool irohPublishSetVideoRenditions({
  required String publisherId,
  required List<String> renditions,
}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohPublishSetVideoRenditions(
      publisherId: publisherId,
      renditions: renditions,
    );

/// Get available video presets
List<FlutterVideoRendition> irohGetVideoPresets() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohGetVideoPresets();

/// Get available audio presets
List<FlutterAudioRendition> irohGetAudioPresets() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohGetAudioPresets();

/// Create a new subscriber (async version with real backend)
Future<void> irohSubscribeCreateAsync({
  required String subscriberId,
  required String broadcastId,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeCreateAsync(
  subscriberId: subscriberId,
  broadcastId: broadcastId,
);

/// Create a new subscriber (sync version for compatibility)
bool irohSubscribeCreate({
  required String subscriberId,
  required String broadcastId,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeCreate(
  subscriberId: subscriberId,
  broadcastId: broadcastId,
);

/// Connect subscriber to broadcast using ticket string (async with real backend)
Future<void> irohSubscribeConnectAsync({
  required String subscriberId,
  required String ticketString,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeConnectAsync(
  subscriberId: subscriberId,
  ticketString: ticketString,
);

/// Connect subscriber to broadcast (sync version)
bool irohSubscribeConnect({required String subscriberId}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohSubscribeConnect(subscriberId: subscriberId);

/// Disconnect subscriber (async with real backend)
Future<void> irohSubscribeDisconnectAsync({required String subscriberId}) =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeDisconnectAsync(
      subscriberId: subscriberId,
    );

/// Disconnect subscriber (sync version)
bool irohSubscribeDisconnect({required String subscriberId}) =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeDisconnect(
      subscriberId: subscriberId,
    );

/// Remove a subscriber
bool irohSubscribeRemove({required String subscriberId}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohSubscribeRemove(subscriberId: subscriberId);

/// Set quality preference for subscriber
bool irohSubscribeSetQuality({
  required String subscriberId,
  required String quality,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeSetQuality(
  subscriberId: subscriberId,
  quality: quality,
);

/// Get subscriber status
FlutterSubscriberStatus? irohSubscribeGetStatus({
  required String subscriberId,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeGetStatus(
  subscriberId: subscriberId,
);

/// Simulate receiving a video frame (for testing)
bool irohSubscribeSimulateVideoReceive({
  required String subscriberId,
  required BigInt frameSize,
}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohSubscribeSimulateVideoReceive(
      subscriberId: subscriberId,
      frameSize: frameSize,
    );

/// Receive a video frame from a subscriber (non-blocking)
/// Returns None if no frame is available
Future<FlutterReceivedVideoFrame?> irohSubscribeReceiveFrame({
  required String subscriberId,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohSubscribeReceiveFrame(
  subscriberId: subscriberId,
);

/// Create a broadcast catalog
FlutterBroadcastCatalog irohCatalogCreate({
  required String broadcastId,
  required List<String> videoRenditions,
  required List<String> audioRenditions,
}) => RustLib.instance.api.crateApiIrohLiveFlutterApiIrohCatalogCreate(
  broadcastId: broadcastId,
  videoRenditions: videoRenditions,
  audioRenditions: audioRenditions,
);

/// Serialize catalog to JSON
String irohCatalogToJson({required FlutterBroadcastCatalog catalog}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohCatalogToJson(catalog: catalog);

/// Parse a ticket string and return its components
FlutterTicketInfo? irohTicketParse({required String ticketString}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohTicketParse(ticketString: ticketString);

/// Get the ticket for a publisher
String? irohPublishGetTicket({required String publisherId}) => RustLib
    .instance
    .api
    .crateApiIrohLiveFlutterApiIrohPublishGetTicket(publisherId: publisherId);

/// Get supported video codecs
List<String> irohGetSupportedVideoCodecs() => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohGetSupportedVideoCodecs();

/// Get supported audio codecs
List<String> irohGetSupportedAudioCodecs() => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohGetSupportedAudioCodecs();

/// Check if a codec is hardware accelerated
bool irohIsCodecHwAccelerated({required String codec}) => RustLib.instance.api
    .crateApiIrohLiveFlutterApiIrohIsCodecHwAccelerated(codec: codec);

/// Get library version
String irohGetVersion() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohGetVersion();

/// Get feature flags
Map<String, bool> irohGetFeatures() =>
    RustLib.instance.api.crateApiIrohLiveFlutterApiIrohGetFeatures();

/// Audio rendition quality info
class FlutterAudioRendition {
  final String name;
  final int sampleRate;
  final int channels;
  final int bitrate;
  final String codec;

  const FlutterAudioRendition({
    required this.name,
    required this.sampleRate,
    required this.channels,
    required this.bitrate,
    required this.codec,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      sampleRate.hashCode ^
      channels.hashCode ^
      bitrate.hashCode ^
      codec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterAudioRendition &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          sampleRate == other.sampleRate &&
          channels == other.channels &&
          bitrate == other.bitrate &&
          codec == other.codec;
}

/// Audio samples for Flutter (raw PCM)
class FlutterAudioSamples {
  final Uint8List data;
  final int sampleRate;
  final int channels;
  final BigInt timestampMs;
  final String format;

  const FlutterAudioSamples({
    required this.data,
    required this.sampleRate,
    required this.channels,
    required this.timestampMs,
    required this.format,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      sampleRate.hashCode ^
      channels.hashCode ^
      timestampMs.hashCode ^
      format.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterAudioSamples &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          sampleRate == other.sampleRate &&
          channels == other.channels &&
          timestampMs == other.timestampMs &&
          format == other.format;
}

/// Broadcast catalog info for Flutter
class FlutterBroadcastCatalog {
  final String broadcastId;
  final List<FlutterTrackInfo> videoTracks;
  final List<FlutterTrackInfo> audioTracks;
  final BigInt createdAtMs;

  const FlutterBroadcastCatalog({
    required this.broadcastId,
    required this.videoTracks,
    required this.audioTracks,
    required this.createdAtMs,
  });

  @override
  int get hashCode =>
      broadcastId.hashCode ^
      videoTracks.hashCode ^
      audioTracks.hashCode ^
      createdAtMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterBroadcastCatalog &&
          runtimeType == other.runtimeType &&
          broadcastId == other.broadcastId &&
          videoTracks == other.videoTracks &&
          audioTracks == other.audioTracks &&
          createdAtMs == other.createdAtMs;
}

/// Capture device info for Flutter
class FlutterCaptureDevice {
  final String id;
  final String name;
  final String deviceType;
  final bool isDefault;

  const FlutterCaptureDevice({
    required this.id,
    required this.name,
    required this.deviceType,
    required this.isDefault,
  });

  @override
  int get hashCode =>
      id.hashCode ^ name.hashCode ^ deviceType.hashCode ^ isDefault.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterCaptureDevice &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          deviceType == other.deviceType &&
          isDefault == other.isDefault;
}

/// Encoded audio packet for Flutter (Opus/AAC)
class FlutterEncodedAudioPacket {
  final Uint8List data;
  final BigInt timestampMs;
  final String codec;
  final int sampleRate;
  final int channels;

  const FlutterEncodedAudioPacket({
    required this.data,
    required this.timestampMs,
    required this.codec,
    required this.sampleRate,
    required this.channels,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      timestampMs.hashCode ^
      codec.hashCode ^
      sampleRate.hashCode ^
      channels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterEncodedAudioPacket &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          timestampMs == other.timestampMs &&
          codec == other.codec &&
          sampleRate == other.sampleRate &&
          channels == other.channels;
}

/// Encoded video packet for Flutter (H264/H265)
/// Use this when encoding is done on the Flutter side (e.g., FFmpegKit)
class FlutterEncodedVideoPacket {
  final Uint8List data;
  final BigInt timestampMs;
  final bool isKeyframe;
  final String codec;
  final int width;
  final int height;

  const FlutterEncodedVideoPacket({
    required this.data,
    required this.timestampMs,
    required this.isKeyframe,
    required this.codec,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      timestampMs.hashCode ^
      isKeyframe.hashCode ^
      codec.hashCode ^
      width.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterEncodedVideoPacket &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          timestampMs == other.timestampMs &&
          isKeyframe == other.isKeyframe &&
          codec == other.codec &&
          width == other.width &&
          height == other.height;
}

/// Publisher status
class FlutterPublisherStatus {
  final String publisherId;
  final bool isActive;
  final BigInt framesPublished;
  final BigInt bytesSent;
  final int currentBitrate;
  final List<String> videoRenditions;
  final List<String> audioRenditions;

  const FlutterPublisherStatus({
    required this.publisherId,
    required this.isActive,
    required this.framesPublished,
    required this.bytesSent,
    required this.currentBitrate,
    required this.videoRenditions,
    required this.audioRenditions,
  });

  @override
  int get hashCode =>
      publisherId.hashCode ^
      isActive.hashCode ^
      framesPublished.hashCode ^
      bytesSent.hashCode ^
      currentBitrate.hashCode ^
      videoRenditions.hashCode ^
      audioRenditions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterPublisherStatus &&
          runtimeType == other.runtimeType &&
          publisherId == other.publisherId &&
          isActive == other.isActive &&
          framesPublished == other.framesPublished &&
          bytesSent == other.bytesSent &&
          currentBitrate == other.currentBitrate &&
          videoRenditions == other.videoRenditions &&
          audioRenditions == other.audioRenditions;
}

/// Received video frame from network
class FlutterReceivedVideoFrame {
  final BigInt timestampMs;
  final int width;
  final int height;
  final bool isKeyframe;
  final Uint8List data;

  const FlutterReceivedVideoFrame({
    required this.timestampMs,
    required this.width,
    required this.height,
    required this.isKeyframe,
    required this.data,
  });

  @override
  int get hashCode =>
      timestampMs.hashCode ^
      width.hashCode ^
      height.hashCode ^
      isKeyframe.hashCode ^
      data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterReceivedVideoFrame &&
          runtimeType == other.runtimeType &&
          timestampMs == other.timestampMs &&
          width == other.width &&
          height == other.height &&
          isKeyframe == other.isKeyframe &&
          data == other.data;
}

/// Subscriber status
class FlutterSubscriberStatus {
  final String subscriberId;
  final String broadcastId;
  final bool isConnected;
  final BigInt framesReceived;
  final BigInt bytesReceived;
  final String currentQuality;
  final double bufferHealth;

  const FlutterSubscriberStatus({
    required this.subscriberId,
    required this.broadcastId,
    required this.isConnected,
    required this.framesReceived,
    required this.bytesReceived,
    required this.currentQuality,
    required this.bufferHealth,
  });

  @override
  int get hashCode =>
      subscriberId.hashCode ^
      broadcastId.hashCode ^
      isConnected.hashCode ^
      framesReceived.hashCode ^
      bytesReceived.hashCode ^
      currentQuality.hashCode ^
      bufferHealth.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterSubscriberStatus &&
          runtimeType == other.runtimeType &&
          subscriberId == other.subscriberId &&
          broadcastId == other.broadcastId &&
          isConnected == other.isConnected &&
          framesReceived == other.framesReceived &&
          bytesReceived == other.bytesReceived &&
          currentQuality == other.currentQuality &&
          bufferHealth == other.bufferHealth;
}

/// Ticket information for Flutter
class FlutterTicketInfo {
  final String broadcastName;
  final String endpointId;
  final String ticketString;

  const FlutterTicketInfo({
    required this.broadcastName,
    required this.endpointId,
    required this.ticketString,
  });

  @override
  int get hashCode =>
      broadcastName.hashCode ^ endpointId.hashCode ^ ticketString.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterTicketInfo &&
          runtimeType == other.runtimeType &&
          broadcastName == other.broadcastName &&
          endpointId == other.endpointId &&
          ticketString == other.ticketString;
}

/// Track info for catalog
class FlutterTrackInfo {
  final String trackId;
  final String name;
  final String codec;
  final int bitrate;
  final Map<String, String> extra;

  const FlutterTrackInfo({
    required this.trackId,
    required this.name,
    required this.codec,
    required this.bitrate,
    required this.extra,
  });

  @override
  int get hashCode =>
      trackId.hashCode ^
      name.hashCode ^
      codec.hashCode ^
      bitrate.hashCode ^
      extra.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterTrackInfo &&
          runtimeType == other.runtimeType &&
          trackId == other.trackId &&
          name == other.name &&
          codec == other.codec &&
          bitrate == other.bitrate &&
          extra == other.extra;
}

/// Video frame data for Flutter (raw, unencoded)
class FlutterVideoFrame {
  final int width;
  final int height;
  final Uint8List data;
  final BigInt timestampMs;
  final String format;

  const FlutterVideoFrame({
    required this.width,
    required this.height,
    required this.data,
    required this.timestampMs,
    required this.format,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      data.hashCode ^
      timestampMs.hashCode ^
      format.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterVideoFrame &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          data == other.data &&
          timestampMs == other.timestampMs &&
          format == other.format;
}

/// Video rendition quality info
class FlutterVideoRendition {
  final String name;
  final int width;
  final int height;
  final int fps;
  final int bitrate;
  final String codec;

  const FlutterVideoRendition({
    required this.name,
    required this.width,
    required this.height,
    required this.fps,
    required this.bitrate,
    required this.codec,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      width.hashCode ^
      height.hashCode ^
      fps.hashCode ^
      bitrate.hashCode ^
      codec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterVideoRendition &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          width == other.width &&
          height == other.height &&
          fps == other.fps &&
          bitrate == other.bitrate &&
          codec == other.codec;
}
